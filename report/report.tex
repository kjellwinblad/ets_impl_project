%\documentclass[aps,pre,preprint,groupedaddress,nofootinbib]{revtex4}
\documentclass[aps,pre,preprint,nofootinbib]{revtex4}
%\documentclass[aps,twocolumn,pre,nofootinbib]{revtex4}   % list options between brackets
\usepackage{}              % list packages between braces

% type user-defined commands here

\begin{document}

\title{Erlang Term Storage Implementation}
\author{Kjell Winblad and Stavros Aronis}
\date{\today}


\begin{abstract}

  This report describe in detail how the Erlang Term Storage (ETS) is implemented.
  The report is created in the RELEASE project as the first step towards creating a more scalable ETS implementation.
  ETS tables are commonly used to share data between processes in Erlang programs.
  It is important to have a very good ETS implementation because shared data is often the bottleneck in concurrent applications.
  The main goals of the report are:
  \begin{itemize}
   \item to get an understanding of the current implementation of the different ETS tables
   \item and to communicate this knowledge to for example the Erlang OTP team. 
  \end{itemize}

\end{abstract}

\maketitle

\section{Introduction}

Erlang Term Storage (ETS) tables is a part of Erlang standard library. 
The ETS tables are used as a way to efficiently share data between processes. 
An Erlang ETS table share many properties with ordinary Erlang processes. 
The programmer can manage ETS tables by a set of built-in functions (BIFs). 
The BIFs are implemented in the C programming language and they are a part of Erlang standard library. An ETS table is identified by an identifier.
The identifier for a table is created with the BIF \verb|ets:new|.
The \verb|ets:new| BIF can take a list of options that can be used to specify: 

\begin{itemize}
 \item 
 If the table type shall be \verb|set|, \verb|bag |, \verb|duplicate_bag| or \verb|ordered_set|. 
 See section~\ref{sec:table_types} for information about the data-structures used in the different table types.
 \item 
 The access level which can be \verb|private|, \verb|protected| and \verb|public|.
 See the Erlang documentation for \verb|ets:new| for more information about these options.
 \item 
 If fine grained locking shall be enabled for read and write can be specified with the options \verb|write_concurrency| and \verb|read_concurrency|. 
 These options may have a large impact on scalability for some applications.
 See section~\ref{sec:concurrency_options} and \ref{sec:benchmark} for more information about these options.
\end{itemize}

All ETS tables are owned by the creating process as long as the creating process is alive and has not given the ownership to an other process with the BIF \verb|ets:give_away|.
If the owner of an ETS table died the table will be deleted, if not the \verb|heir| option is set.
The programmer can use the \verb|heir| option to specify a process that will inherit the table when it dies. 
If a process has been specified with the \verb|heir| option it will get a message from the previous owner when the previous owner dies.

\subsection{Overview of Table Operations}

This section gives an overview of the most fundamental ETS table operations. 
See the Erlang documentation for ETS tables for a complete description of all table operations. 
See section~\ref{sec:table_types} for information about the data-structures used in the tables.

\begin{description}
 \item[lookup(Tab, Key) $\rightarrow$ [Object]] 
 Returns a list of elements with the given key. 
 Calls to \verb|lookup| and \verb|insert| can be done concurrently if \verb|read_concurrency| is activated when \verb|set|, \verb|bag | or \verb|duplicate_bag| is used.
 \item[insert(Tab, ObjectOrObjects) $\rightarrow$ true]
 Insert the given object or objects in case the parameter is a list of objects.
 Several inserts can be done concurrently if \verb|write_concurrency| is activated when \verb|set|, \verb|bag | or \verb|duplicate_bag| is used.
 \item[insert\_new(Tab, ObjectOrObjects) $\rightarrow$ true]
 This operation will insert the given object or objects if no object with the same key as any of the object(s) exists. 
 If a key already exists the operation will return false.
 \item[delete(Tab, Key) $\rightarrow$ true] Deletes all objects with the given key from the table.
 \item[first(Tab) $\rightarrow$ Key $|$ \texttt{end\_of\_table} ] Returns the first key in the table. If the table is of the \verb|ordered_set| type, the first key in Erlang term order will be returned. If the table is of any other type, the first key according to the table's internal order will be returned. If the table is empty, \verb|end_of_table| will be returned.
 \item[last(Tab) $\rightarrow$ Key $|$ \texttt{end\_of\_table} ] Returns the last key in the table.
\end{description}

\section{Handling of Tables}

The infrastructure for the handling of tables is described in this section. 
An overview of the data-structures involved is provided in section~\ref{sec:tables_overview}.
How locking is done when tables are accessed concurrently is described in section~\ref{sec:tables_locking}.

\subsection{Overview} \label{sec:tables_overview}

\subsubsection{Global data structures}

\begin{description}
  \item[meta\_main\_table] Contains all the tables. TIDs map to a slot.
  \item[meta\_name\_table] Keys are atoms, values are TIDs.
  \item[meta\_pid\_to\_tab] Maps processes (PIDs) to tables owned by them.
  \item[meta\_pid\_to\_fixed\_tab] Maps processes (PIDs) to tables that are
    fixated by them.
\end{description}

\subsection{Locking} \label{sec:tables_locking}

Different levels of locking are required for each operation on an ETS table.

\section{Table Types} \label{sec:table_types}

Tables of type \verb|set|, \verb|bag| and \verb|duplicate_bag| do not impose any particular order between their entries. These tables are implemented in the runtime system as hash tables. In contrast, \verb|ordered_set| tables have their entries ordered according to their keys and are therefore implemented as AVL trees. The runtime system is structured in such a way that operations which are transparent to the underlying implementation of a table are handled with normal C functions, while operations that depend on the implementation are dispatched from the equivalent of a method table.

\subsection{Hash tables}

\subsection{Set}     % section 2.1

\subsubsection{Data Structure}
\subsubsection{Expanding}
\subsubsection{Shrinking}

\subsection{Bag}
\subsection{Duplicate Bag}
\subsection{Ordered Set}


\section{Concurrency Options} \label{sec:concurrency_options}

\subsection{Write Concurrency}

\subsection{Read Concurrency}

\section{Fixation}

A process can call \texttt{ets:safe\_fixtable(Table, true $|$ false)} to put a fixation on a table implemented with a hash table (\verb|set|, \verb|bag| or \verb|duplicate_bag|). When a table is fixed, a sequence of \verb|first/1| and \verb|next/2| calls are guaranteed to succeed and each object in the table will only be returned once, even if objects are removed or inserted during the traversal. The keys for new objects inserted during the traversal may be returned by \verb|next/2| (it depends on the internal ordering of the keys). In essence this translates to the following 2 guarantees:

\begin{enumerate}
  \item Keys will not totally disappear from the table. A key can thus be used as an iterator to find the next key in iteration sequence. Note however that this does not mean that (pointers to) table objects are guaranteed to be maintained while the table is fixated. A BAG or DBAG may actually remove objects as long as there is at least one object left in the table with the same key (alive or pseudo-deleted).
    \item Objects will not be moved between buckets due to table grow/shrink. This will guarantee that iterations do not miss keys or get double-hits.
\end{enumerate}

\section{Benchmark} \label{sec:benchmark}

\subsection{Description}

\subsection{Results}


\section{Scalable ETS Suggestions}

\begin{thebibliography}{9}
  % type bibliography here
\end{thebibliography}

\end{document}
