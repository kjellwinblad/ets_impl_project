%\documentclass[aps,pre,preprint,groupedaddress,nofootinbib]{revtex4}
\documentclass[aps,pre,preprint,nofootinbib]{revtex4}
%\documentclass[aps,twocolumn,pre,nofootinbib]{revtex4}   % list options between brackets
\usepackage{listings}              % list packages between braces
\usepackage{graphicx}
\usepackage{epstopdf}

% type user-defined commands here

\begin{document}

\title{Erlang Term Storage Implementation}
\author{Kjell Winblad and Stavros Aronis}
\date{\today}


\begin{abstract}

  This report describe in detail how the Erlang Term Storage (ETS) is implemented.
  The report is created in the RELEASE project as the first step towards creating a more scalable ETS implementation.
  ETS tables are commonly used to share data between processes in Erlang programs.
  It is important to have a very good ETS implementation because shared data is often the bottleneck in concurrent applications.
  The main goals of the report are:
  \begin{itemize}
   \item to get an understanding of the current implementation of the different ETS tables
   \item and to communicate this knowledge to for example the Erlang OTP team. 
  \end{itemize}

\end{abstract}

\maketitle

\section{Introduction}

Erlang Term Storage (ETS) tables is a part of Erlang standard library. 
The ETS tables are used as a way to efficiently share data between processes. 
An Erlang ETS table share many properties with ordinary Erlang processes. 
The programmer can manage ETS tables by a set of built-in functions (BIFs). 
The BIFs are implemented in the C programming language and they are a part of Erlang standard library. An ETS table is identified by an identifier.
The identifier for a table is created with the BIF \verb|ets:new|.
The \verb|ets:new| BIF can take a list of options that can be used to specify: 

\begin{itemize}
 \item 
 If the table type shall be \verb|set|, \verb|bag |, \verb|duplicate_bag| or \verb|ordered_set|. 
 See section~\ref{sec:table_types} for information about the data-structures used in the different table types.
 \item 
 The access level which can be \verb|private|, \verb|protected| and \verb|public|.
 See the Erlang documentation for \verb|ets:new| for more information about these options.
 \item 
 If fine grained locking shall be enabled for read and write can be specified with the options \verb|write_concurrency| and \verb|read_concurrency|. 
 These options may have a large impact on scalability for some applications.
 See section~\ref{sec:concurrency_options} and \ref{sec:benchmark} for more information about these options.
\end{itemize}

All ETS tables are owned by the creating process as long as the creating process is alive and has not given the ownership to an other process with the BIF \verb|ets:give_away|.
If the owner of an ETS table died the table will be deleted, if not the \verb|heir| option is set.
The programmer can use the \verb|heir| option to specify a process that will inherit the table when it dies. 
If a process has been specified with the \verb|heir| option it will get a message from the previous owner when the previous owner dies.

\subsection{Overview of Table Operations}

This section gives an overview of the most fundamental ETS table operations. 
See the Erlang documentation for ETS tables for a complete description of all table operations. 
See section~\ref{sec:table_types} for information about the data-structures used in the tables.

\begin{description}
 \item[lookup(Tab, Key) $\rightarrow$ [Object]] 
 Returns a list of elements with the given key. 
 Calls to \verb|lookup| and \verb|insert| can be done concurrently if \verb|read_concurrency| is activated when \verb|set|, \verb|bag | or \verb|duplicate_bag| is used.
 \item[insert(Tab, ObjectOrObjects) $\rightarrow$ true]
 Insert the given object or objects in case the parameter is a list of objects.
 Several inserts can be done concurrently if \verb|write_concurrency| is activated when \verb|set|, \verb|bag | or \verb|duplicate_bag| is used.
 \item[insert\_new(Tab, ObjectOrObjects) $\rightarrow$ true]
 This operation will insert the given object or objects if no object with the same key as any of the object(s) exists. 
 If a key already exists the operation will return false.
 \item[delete(Tab, Key) $\rightarrow$ true] Deletes all objects with the given key from the table.
 \item[first(Tab) $\rightarrow$ Key $|$ \texttt{end\_of\_table} ] Returns the first key in the table. If the table is of the \verb|ordered_set| type, the first key in Erlang term order will be returned. If the table is of any other type, the first key according to the table's internal order will be returned. If the table is empty, \verb|end_of_table| will be returned.
 \item[last(Tab) $\rightarrow$ Key $|$ \texttt{end\_of\_table} ] Returns the last key in the table.
\end{description}

\section{Handling of Tables}

The infrastructure for the handling of tables is described in this section. 
An overview of the data-structures involved is provided in section~\ref{sec:tables_overview}.
How locking is done when tables are accessed concurrently is described in section~\ref{sec:tables_locking}.

\subsection{Overview} \label{sec:tables_overview}

\subsubsection{Global data structures}

\begin{description}
  \item[meta\_main\_table] Contains all the tables. TIDs map to a slot.
  \item[meta\_name\_table] Keys are atoms, values are TIDs.
  \item[meta\_pid\_to\_tab] Maps processes (PIDs) to tables owned by them.
  \item[meta\_pid\_to\_fixed\_tab] Maps processes (PIDs) to tables that are
    fixated by them.
\end{description}

\subsection{Locking} \label{sec:tables_locking}

Different levels of locking are required for each operation on an ETS table.

\section{Table Types} \label{sec:table_types}

Tables of type \verb|set|, \verb|bag| and \verb|duplicate_bag| do not impose any particular order between their entries. These tables are implemented in the runtime system as hash tables. In contrast, \verb|ordered_set| tables have their entries ordered according to their keys and are therefore implemented as AVL trees. The runtime system is structured in such a way that operations which are transparent to the underlying implementation of a table are handled with normal C functions, while operations that depend on the implementation are dispatched from the equivalent of a method table.

\subsection{Hash tables}

\subsection{Set}     % section 2.1

\subsubsection{Data Structure}
\subsubsection{Expanding}
\subsubsection{Shrinking}

\subsection{Bag}
\subsection{Duplicate Bag}
\subsection{Ordered Set}


\section{Concurrency Options} \label{sec:concurrency_options}

\subsection{Write Concurrency}

\subsection{Read Concurrency}

\section{Fixation}

A process can call \texttt{ets:safe\_fixtable(Table, true $|$ false)} to put a fixation on a table implemented with a hash table (\verb|set|, \verb|bag| or \verb|duplicate_bag|). When a table is fixed, a sequence of \verb|first/1| and \verb|next/2| calls are guaranteed to succeed and each object in the table will only be returned once, even if objects are removed or inserted during the traversal. The keys for new objects inserted during the traversal may be returned by \verb|next/2| (it depends on the internal ordering of the keys). In essence this translates to the following 2 guarantees:

\begin{enumerate}
  \item Keys will not totally disappear from the table. A key can thus be used as an iterator to find the next key in iteration sequence. Note however that this does not mean that (pointers to) table objects are guaranteed to be maintained while the table is fixated. A BAG or DBAG may actually remove objects as long as there is at least one object left in the table with the same key (alive or pseudo-deleted).
    \item Objects will not be moved between buckets due to table grow/shrink. This will guarantee that iterations do not miss keys or get double-hits.
\end{enumerate}

\section{Benchmark} \label{sec:benchmark}

  A simple benchmark has been performed.
  The benchmark is created to see how the \verb|write_concurrency| and \verb|read_concurrency| options that effects the performance for the different table types on a real world problem.
  The benchmark creates workers that all do \verb|lookup| and \verb|insert| on the same ETS table (cache).
  The benchmark was done on a computer with 64 cores.
  We run the benchmark program with all different combinations of \verb|write_concurrency|, \verb|read_concurrency| and the different table types: \verb|set| and \verb|ordered_set| with 1 to 30 workers.
  
  \subsection{Benchmark Problem}
    The benchmark program finds the minimum number of steps to sort an array with a few constraints.
    The array contains \emph{black} marks, \emph{white} marks and \emph{empty} positions.
    An array can be represented as for example \verb|"ebbwe"|, where \verb|e| represent \emph{empty} position, \verb|w| represent a \emph{white} mark and \verb|b| a \emph{black} mark.
    Black marks can only move in the right direction and white marks can only move in the left direction.
    In one sort step a mark can:
    \begin{itemize}
     \item move one step in the array if the neighbor position in the direction of the movement is empty or
     \item move two steps in the array if the neighbor position in the direction of the movement contains a mark and the next position is empty.
    \end{itemize}
    A sorted array has all whites as far to the right in the array as possible and all blacks as far right to the array as possible.
    Some input arrays can not be sorted with the given constraints, e.g. \verb|"bbww"|.
    If the input array can not be sorted the program shall return -1.
    The minimum number of steps for \verb|"ebbwe"| is 5.
    The benchmark timed the time it took to return the result for the arrays \verb|"bebebbeeeewwwbw"|, \verb|"bebebeeewewewewwe"|.
    
  \subsection{Implementation}
    The Erlang program that solves the benchmark problem is available at www.github.com\footnote{http://github.com/kjellwinblad/ets\_impl\_project/blob/master/benchmark/multi\_4.erl}.
    The program explores the the possible solutions in a breath first search manner.
    Explored configurations are saved in an ETS table to avoid repeating work.
    The program has one coordinator process and a number of worker process.
    At a specific level in the search tree the coordinator divides configurations that needs to be explored in the next level evenly to the workers.
    The workers check if the given configuration is a solution.
    If it is not a solution it is expanded by generating all possible configurations that can be creating by doing one sort step.
    Directly after a configuration is generated it is checked if it already exists in the ETS table cache with the \verb|ets:member| function.
    If it already exists, it is thrown away because the configuration has already been visited.
    Otherwise, the configuration is inserted in the ETS table with the \verb|ets:inser_new| operation.
    The return value of \verb|ets:insert_new| is checked to make sure that the configuration has not been inserted by another process between the call to \verb|ets:member| and \verb|ets:insert_new|.
    The Erlang code that is interacting with the ETS table cache in the workers can be seen in listing~\ref{li_erlang_ets_interaction}.

    \lstset{language=erlang, caption=Worker code that is interacting with ETS, label=li_erlang_ets_interaction} 
\begin{lstlisting} 
IsFound = ets:member(Cache, MoveArray),
case IsFound of
  false ->
    Inserted = ets:insert_new(Cache, {MoveArray}),
    case Inserted of
      true ->
        [MoveArray|all_next_step_arrays(Array, CurrentPos + 1, Cache)];
      false ->
        all_next_step_arrays(Array, CurrentPos + 1, Cache)
    end;
  true ->
    all_next_step_arrays(Array, CurrentPos + 1, Cache)
end
\end{lstlisting}
    
    A worker send back all configurations that needs to be explored in the next level to the coordinator when it has processed all given configurations on the current level.


\subsection{Results}

  The results of the benchmark can be seen in figure~\ref{fig:benchmark_results}.

\begin{figure}[htb]
\centering
\includegraphics[width=1.0\textwidth]{benchmark.eps}
\caption{Benchmark Results} 
\label{fig:benchmark_results}
\end{figure}


\section{Scalable ETS Suggestions}

\begin{thebibliography}{9}
  % type bibliography here 
\end{thebibliography}

\end{document}
