%\documentclass[aps,pre,preprint,groupedaddress,nofootinbib]{revtex4}
\documentclass[aps,pre,preprint,nofootinbib]{revtex4}
%\documentclass[aps,twocolumn,pre,nofootinbib]{revtex4}   % list options between brackets
\usepackage{listings}              % list packages between braces
\usepackage{graphicx}
\usepackage{epstopdf}

% type user-defined commands here

\begin{document}

\title{Erlang Term Storage Implementation}
\author{Kjell Winblad and Stavros Aronis}
\date{\today}


\begin{abstract}

  This report describe in detail how the Erlang Term Storage (ETS) is implemented.
  The report is created in the RELEASE project as the first step towards creating a more scalable ETS implementation.
  ETS tables are commonly used to share data between processes in Erlang programs.
  It is important to have a very good ETS implementation because shared data is often the bottleneck in concurrent applications.
  The main goals of the report are:
  \begin{itemize}
   \item to get an understanding of the current implementation of the different ETS tables
   \item and to communicate this knowledge to for example the Erlang OTP team. 
  \end{itemize}

\end{abstract}

\maketitle

\section{Introduction}

Erlang Term Storage (ETS) tables is a part of Erlang standard library. 
The ETS tables are used as a way to efficiently share data between processes. 
An Erlang ETS table share many properties with ordinary Erlang processes. 
The programmer can manage ETS tables by a set of built-in functions (BIFs). 
The BIFs are implemented in the C programming language and they are a part of Erlang standard library.
An ETS table is identified by an identifier.
The identifier for a table is created with the BIF \verb|ets:new|.
The \verb|ets:new| BIF can take a list of options that can be used to specify: 

\begin{itemize}
 \item 
 If the table type shall be \verb|set|, \verb|bag |, \verb|duplicate_bag| or \verb|ordered_set|. 
 See section~\ref{sec:table_types} for information about the data-structures used in the different table types.
 \item 
 The access level which can be \verb|private|, \verb|protected| and \verb|public|.
 See the Erlang documentation for \verb|ets:new| for more information about these options.
 \item 
 If fine grained locking shall be enabled for read and write can be specified with the options \verb|write_concurrency| and \verb|read_concurrency|. 
 These options may have a large impact on scalability for some applications.
 See section~\ref{sec:concurrency_options} and \ref{sec:benchmark} for more information about these options.
\end{itemize}

All ETS tables are owned by the creating process as long as the creating process is alive and has not given the ownership to an other process with the BIF \verb|ets:give_away|.
If the owner of an ETS table died the table will be deleted, if not the \verb|heir| option is set.
The programmer can use the \verb|heir| option to specify a process that will inherit the table when it dies. 
If a process has been specified with the \verb|heir| option it will get a message from the previous owner when the previous owner dies.

\subsection{Overview of Table Operations}

This section gives an overview of the most fundamental ETS table operations. 
See the Erlang documentation for ETS tables for a complete description of all table operations. 
See section~\ref{sec:table_types} for information about the data-structures used in the tables.

\begin{description}
 \item[lookup(Tab, Key) $\rightarrow$ [Object]] 
 Returns a list of elements with the given key. 
 Calls to \verb|lookup| and \verb|insert| can be done concurrently if \verb|read_concurrency| is activated when \verb|set|, \verb|bag | or \verb|duplicate_bag| is used.
 \item[insert(Tab, ObjectOrObjects) $\rightarrow$ true]
 Insert the given object or objects in case the parameter is a list of objects.
 Several inserts can be done concurrently if \verb|write_concurrency| is activated when \verb|set|, \verb|bag | or \verb|duplicate_bag| is used.
 \item[insert\_new(Tab, ObjectOrObjects) $\rightarrow$ true]
 This operation will insert the given object or objects if no object with the same key as any of the object(s) exists. 
 If a key already exists the operation will return false.
\end{description}


\section{Handling of Tables}

The infrastructure for the handling of tables is described in this section. 
An overview of the data-structures involved is provided in section~\ref{sec:tables_overview}.
How locking is done when tables are accessed concurrently is described in section~\ref{sec:tables_locking}.

\subsection{Overview} \label{sec:tables_overview}


\subsubsection{Global data structures}


\begin{description}
  \item[meta\_main\_table] Contains all the tables. TIDs map to a slot.
  \item[meta\_main\_table] The meta table can contain a maximum of 2053 tables. 
  This maximum can be changed by the setting the  environment variable \verb|DB_DEF_MAX_TABS|.
  The size is fixed during the liftime of the Erlang VM.
  \item[meta\_name\_table] Keys are atoms, values are TIDs.
  \item[meta\_pid\_to\_tab] Maps processes (PIDs) to tables owned by them.
  \item[meta\_pid\_to\_fixed\_tab] Maps processes (PIDs) to tables that are
    fixated by them.
\end{description}

\subsection{Locking} \label{sec:tables_locking}


\section{Table Types} \label{sec:table_types}

\subsection{Set}     % section 2.1
\subsubsection{Data Structure}
\subsubsection{Expanding}
\subsubsection{Shrinking}

\subsection{Bag}
\subsection{Duplicate Bag}
\subsection{Ordered Set}


\section{Concurrency Options} \label{sec:concurrency_options}

\subsection{Write Concurrency}

\subsection{Read Concurrency}


\section{Benchmark} \label{sec:benchmark}

  A simple benchmark has been performed.
  The benchmark is created to see how the \verb|write_concurrency| and \verb|read_concurrency| options that effects the performance for the different table types on a real world problem.
  The benchmark creates workers that all do \verb|lookup| and \verb|insert| on the same ETS table (cache).
  The benchmark was done on a computer with 64 cores.
  We run the benchmark program with all different combinations of \verb|write_concurrency|, \verb|read_concurrency| and the different table types: \verb|set| and \verb|ordered_set| with 1 to 30 workers.
  
  \subsection{Benchmark Problem}
    The benchmark program finds the minimum number of steps to sort an array with a few constraints.
    The array contains \emph{black} marks, \emph{white} marks and \emph{empty} positions.
    An array can be represented as for example \verb|"ebbwe"|, where \verb|e| represent \emph{empty} position, \verb|w| represent a \emph{white} mark and \verb|b| a \emph{black} mark.
    Black marks can only move in the right direction and white marks can only move in the left direction.
    In one sort step a mark can:
    \begin{itemize}
     \item move one step in the array if the neighbor position in the direction of the movement is empty or
     \item move two steps in the array if the neighbor position in the direction of the movement contains a mark and the next position is empty.
    \end{itemize}
    A sorted array has all whites as far to the right in the array as possible and all blacks as far right to the array as possible.
    Some input arrays can not be sorted with the given constraints, e.g. \verb|"bbww"|.
    If the input array can not be sorted the program shall return -1.
    The minimum number of steps for \verb|"ebbwe"| is 5.
    The benchmark timed the time it took to return the result for the arrays \verb|"bebebbeeeewwwbw"|, \verb|"bebebeeewewewewwe"|.
    
  \subsection{Implementation}
    The Erlang program that solves the benchmark problem is available at www.github.com\footnote{http://github.com/kjellwinblad/ets\_impl\_project/blob/master/benchmark/multi\_4.erl}.
    The program explores the the possible solutions in a breath first search manner.
    Explored configurations are saved in an ETS table to avoid repeating work.
    The program has one coordinator process and a number of worker process.
    At a specific level in the search tree the coordinator divides configurations that needs to be explored in the next level evenly to the workers.
    The workers check if the given configuration is a solution.
    If it is not a solution it is expanded by generating all possible configurations that can be creating by doing one sort step.
    Directly after a configuration is generated it is checked if it already exists in the ETS table cache with the \verb|ets:member| function.
    If it already exists, it is thrown away because the configuration has already been visited.
    Otherwise, the configuration is inserted in the ETS table with the \verb|ets:inser_new| operation.
    The return value of \verb|ets:insert_new| is checked to make sure that the configuration has not been inserted by another process between the call to \verb|ets:member| and \verb|ets:insert_new|.
    The Erlang code that is interacting with the ETS table cache in the workers can be seen in listing~\ref{li_erlang_ets_interaction}.

    \lstset{language=erlang, caption=Worker code that is interacting with ETS, label=li_erlang_ets_interaction} 
\begin{lstlisting} 
IsFound = ets:member(Cache, MoveArray),
case IsFound of
  false ->
    Inserted = ets:insert_new(Cache, {MoveArray}),
    case Inserted of
      true ->
        [MoveArray|all_next_step_arrays(Array, CurrentPos + 1, Cache)];
      false ->
        all_next_step_arrays(Array, CurrentPos + 1, Cache)
    end;
  true ->
    all_next_step_arrays(Array, CurrentPos + 1, Cache)
end
\end{lstlisting}
    
    A worker send back all configurations that needs to be explored in the next level to the coordinator when it has processed all given configurations on the current level.


\subsection{Results}

  The results of the benchmark can be seen in figure~\ref{fig:benchmark_results}.

\begin{figure}[htb]
\centering
\includegraphics[width=1.0\textwidth]{benchmark.eps}
\caption{Benchmark Results} 
\label{fig:benchmark_results}
\end{figure}


\section{Scalable ETS Suggestions}

\begin{thebibliography}{9}
  % type bibliography here 
\end{thebibliography}

\end{document}
